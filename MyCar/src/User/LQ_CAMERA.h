#ifndef __LQ_CAMERA_H
#define __LQ_CAMERA_H

#define IMAGEH  MT9V034_IMAGEH
#define IMAGEW  MT9V034_IMAGEW

#define LCDH    60  //显示的行数
#define LCDW    94  //显示的列数

extern volatile uint8_t Image_Data[IMAGEH][IMAGEW];      //图像原始数据存放
extern uint8_t Image_Use[LCDH][LCDW];           //压缩后之后用于存放屏幕显示数据
extern uint8_t Pixle[LCDH][LCDW];               //二值化后用于OLED显示的数据
extern volatile uint8_t  Line_Cont;                    //行计数
extern volatile uint8_t  Field_Over_Flag;              //场标识

/*---------------------------------------------------------------
【函    数】Test_Camera
【功    能】测试摄像头 在OLED上显示图像
【参    数】无
【返 回 值】无
【注意事项】注意不要使用 灯PD15
----------------------------------------------------------------*/
void Test_Camera(void);


/*---------------------------------------------------------------
【函    数】Get_Use_Image
【功    能】获取需要使用的图像大小
【参    数】无
【返 回 值】无
【注意事项】
----------------------------------------------------------------*/
void Get_Use_Image(void);


/*---------------------------------------------------------------
【函    数】Get_01_Value
【功    能】二值化
【参    数】mode  ：  0：使用大津法阈值    1：使用平均阈值
【返 回 值】无
【注意事项】
----------------------------------------------------------------*/
void Get_01_Value(uint8_t mode);


/*---------------------------------------------------------------
【函    数】TFTSPI_Show_Cmera
【功    能】在TFT1.8上画出摄像头的图像
【参    数】xs:  起始X   
【参    数】ys:  起始Y  
【参    数】w:   图片宽度 
【参    数】h:   图片高度  
【参    数】ppic[IMAGEH][IMAGEW]:  图片缓存区   
【返 回 值】无
【注意事项】
----------------------------------------------------------------*/	
void TFTSPI_Show_Cmera(uint8_t xs,uint8_t ys,uint8_t w,uint8_t h,uint8_t ppic[LCDH][LCDW]); 


/*---------------------------------------------------------------
【函    数】Draw_Road
【功    能】在OLED上画出摄像头的图像
【参    数】无
【返 回 值】无
【注意事项】
----------------------------------------------------------------*/
void Draw_Road(void);


/*---------------------------------------------------------------
【函    数】Pixle_Filter
【功    能】过滤噪点
【参    数】无
【返 回 值】无
【注意事项】
----------------------------------------------------------------*/
void Pixle_Filter(void);


/***************************************************************
* 
* 函数名称：SendPicture 
* 功能说明：发送图像到上位机 ，不同的上位机注意修改对应的数据接收协议
* 参数说明： 
* 函数返回：void 
* 修改时间：2018年3月27日 
* 备 注： 
***************************************************************/ 
void UARTSendPicture(uint8_t  tmImage[IMAGEH][IMAGEW]);


/*************************************************************** 
* 
* 函数名称：uint8_t GetOSTU(uint8_t tmImage[IMAGEH][IMAGEW]) 
* 功能说明：求阈值大小 
* 参数说明： 
* 函数返回：阈值大小 
* 修改时间：2018年3月27日 
* 备 注： 
参考：https://blog.csdn.net/zyzhangyue/article/details/45841255
      https://www.cnblogs.com/moon1992/p/5092726.html
      https://www.cnblogs.com/zhonghuasong/p/7250540.html     
Ostu方法又名最大类间差方法，通过统计整个图像的直方图特性来实现全局阈值T的自动选取，其算法步骤为：
1) 先计算图像的直方图，即将图像所有的像素点按照0~255共256个bin，统计落在每个bin的像素点数量
2) 归一化直方图，也即将每个bin中像素点数量除以总的像素点
3) i表示分类的阈值，也即一个灰度级，从0开始迭代
4) 通过归一化的直方图，统计0~i 灰度级的像素(假设像素值在此范围的像素叫做前景像素) 所占整幅图像的比例w0，并统计前景像素的平均灰度u0；统计i~255灰度级的像素(假设像素值在此范围的像素叫做背景像素) 所占整幅图像的比例w1，并统计背景像素的平均灰度u1；
5) 计算前景像素和背景像素的方差 g = w0*w1*(u0-u1) (u0-u1)
6) i++；转到4)，直到i为256时结束迭代
7）将最大g相应的i值作为图像的全局阈值
缺陷:OSTU算法在处理光照不均匀的图像的时候，效果会明显不好，因为利用的是全局像素信息。
***************************************************************/ 
int GetOSTU(uint8_t tmImage[LCDH][LCDW]);

/*---------------------------------------------------------------
【函    数】Test_Camera
【功    能】测试摄像头 
【参    数】无
【返 回 值】无
【注意事项】注意不要使用 灯PD15
----------------------------------------------------------------*/
void CAMERA_Init(void);

#endif